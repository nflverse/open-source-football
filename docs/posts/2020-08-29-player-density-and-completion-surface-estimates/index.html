<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">

<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"/>
  <meta name="generator" content="distill" />

  <style type="text/css">
  /* Hide doc at startup (prevent jankiness while JS renders/transforms) */
  body {
    visibility: hidden;
  }
  </style>

 <!--radix_placeholder_import_source-->
 <!--/radix_placeholder_import_source-->

  <!--radix_placeholder_meta_tags-->
<title>Open Source Football: Player Density and Completion Surface Estimates</title>

<meta property="description" itemprop="description" content="Methods for modeling density estimates and expected completion percentages across the football field for individual players."/>

<link rel="canonical" href="https://mrcaseb.github.io/open-source-football/posts/2020-08-29-player-density-and-completion-surface-estimates/"/>
<link rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"/>
<link rel="icon" type="image/png" href="../../logo.png"/>

<!--  https://schema.org/Article -->
<meta property="article:published" itemprop="datePublished" content="2020-08-29"/>
<meta property="article:created" itemprop="dateCreated" content="2020-08-29"/>
<meta name="article:author" content="Ethan Douglas"/>

<!--  https://developers.facebook.com/docs/sharing/webmasters#markup -->
<meta property="og:title" content="Open Source Football: Player Density and Completion Surface Estimates"/>
<meta property="og:type" content="article"/>
<meta property="og:description" content="Methods for modeling density estimates and expected completion percentages across the football field for individual players."/>
<meta property="og:url" content="https://mrcaseb.github.io/open-source-football/posts/2020-08-29-player-density-and-completion-surface-estimates/"/>
<meta property="og:image" content="https://mrcaseb.github.io/open-source-football/posts/2020-08-29-player-density-and-completion-surface-estimates/player-density-and-completion-surface-estimates_files/figure-html5/plotting-1.png"/>
<meta property="og:image:width" content="6240"/>
<meta property="og:image:height" content="4290"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:site_name" content="Open Source Football"/>

<!--  https://dev.twitter.com/cards/types/summary -->
<meta property="twitter:card" content="summary_large_image"/>
<meta property="twitter:title" content="Open Source Football: Player Density and Completion Surface Estimates"/>
<meta property="twitter:description" content="Methods for modeling density estimates and expected completion percentages across the football field for individual players."/>
<meta property="twitter:url" content="https://mrcaseb.github.io/open-source-football/posts/2020-08-29-player-density-and-completion-surface-estimates/"/>
<meta property="twitter:image" content="https://mrcaseb.github.io/open-source-football/posts/2020-08-29-player-density-and-completion-surface-estimates/player-density-and-completion-surface-estimates_files/figure-html5/plotting-1.png"/>
<meta property="twitter:image:width" content="6240"/>
<meta property="twitter:image:height" content="4290"/>
<meta property="twitter:site" content="@Open_Source_FB"/>

<!--  https://scholar.google.com/intl/en/scholar/inclusion.html#indexing -->
<meta name="citation_title" content="Open Source Football: Player Density and Completion Surface Estimates"/>
<meta name="citation_fulltext_html_url" content="https://mrcaseb.github.io/open-source-football/posts/2020-08-29-player-density-and-completion-surface-estimates/"/>
<meta name="citation_fulltext_world_readable" content=""/>
<meta name="citation_online_date" content="2020/08/29"/>
<meta name="citation_publication_date" content="2020/08/29"/>
<meta name="citation_author" content="Ethan Douglas"/>
<!--/radix_placeholder_meta_tags-->
  <!--radix_placeholder_rmarkdown_metadata-->

<script type="text/json" id="radix-rmarkdown-metadata">
{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["creative_commons","title","description","author","date","output","repository_url","categories","citation_url","canonical_url"]}},"value":[{"type":"character","attributes":{},"value":["CC BY-NC"]},{"type":"character","attributes":{},"value":["Player Density and Completion Surface Estimates"]},{"type":"character","attributes":{},"value":["Methods for modeling density estimates and expected completion percentages across the football field for individual players."]},{"type":"list","attributes":{},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","url"]}},"value":[{"type":"character","attributes":{},"value":["Ethan Douglas"]},{"type":"character","attributes":{},"value":["https://twitter.com/ChiefsAnalytics"]}]}]},{"type":"character","attributes":{},"value":["08-29-2020"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["distill::distill_article"]}},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["self_contained","toc","toc_depth"]}},"value":[{"type":"logical","attributes":{},"value":[false]},{"type":"logical","attributes":{},"value":[true]},{"type":"integer","attributes":{},"value":[3]}]}]},{"type":"character","attributes":{},"value":["https://github.com/mrcaseb/open-source-football"]},{"type":"character","attributes":{},"value":["nflfastR","python"]},{"type":"character","attributes":{},"value":["https://mrcaseb.github.io/open-source-football/posts/2020-08-29-player-density-and-completion-surface-estimates/"]},{"type":"character","attributes":{},"value":["https://mrcaseb.github.io/open-source-football/posts/2020-08-29-player-density-and-completion-surface-estimates/"]}]}
</script>
<!--/radix_placeholder_rmarkdown_metadata-->
  
  <script type="text/json" id="radix-resource-manifest">
  {"type":"character","attributes":{},"value":["player-density-and-completion-surface-estimates_files/bowser-1.9.3/bowser.min.js","player-density-and-completion-surface-estimates_files/distill-2.2.21/template.v2.js","player-density-and-completion-surface-estimates_files/figure-html5/comp_diff-1.png","player-density-and-completion-surface-estimates_files/figure-html5/comp_surface-1.png","player-density-and-completion-surface-estimates_files/figure-html5/gam-1.png","player-density-and-completion-surface-estimates_files/figure-html5/masked-1.png","player-density-and-completion-surface-estimates_files/figure-html5/partial_dependencies-1.png","player-density-and-completion-surface-estimates_files/figure-html5/partial_dependencies-2.png","player-density-and-completion-surface-estimates_files/figure-html5/plotting-1.png","player-density-and-completion-surface-estimates_files/jquery-1.11.3/jquery.min.js","player-density-and-completion-surface-estimates_files/webcomponents-2.0.0/webcomponents.js"]}
  </script>
  <!--radix_placeholder_navigation_in_header-->
<meta name="distill:offset" content="../.."/>

<script type="application/javascript">

  window.headroom_prevent_pin = false;

  window.document.addEventListener("DOMContentLoaded", function (event) {

    // initialize headroom for banner
    var header = $('header').get(0);
    var headerHeight = header.offsetHeight;
    var headroom = new Headroom(header, {
      tolerance: 5,
      onPin : function() {
        if (window.headroom_prevent_pin) {
          window.headroom_prevent_pin = false;
          headroom.unpin();
        }
      }
    });
    headroom.init();
    if(window.location.hash)
      headroom.unpin();
    $(header).addClass('headroom--transition');

    // offset scroll location for banner on hash change
    // (see: https://github.com/WickyNilliams/headroom.js/issues/38)
    window.addEventListener("hashchange", function(event) {
      window.scrollTo(0, window.pageYOffset - (headerHeight + 25));
    });

    // responsive menu
    $('.distill-site-header').each(function(i, val) {
      var topnav = $(this);
      var toggle = topnav.find('.nav-toggle');
      toggle.on('click', function() {
        topnav.toggleClass('responsive');
      });
    });

    // nav dropdowns
    $('.nav-dropbtn').click(function(e) {
      $(this).next('.nav-dropdown-content').toggleClass('nav-dropdown-active');
      $(this).parent().siblings('.nav-dropdown')
         .children('.nav-dropdown-content').removeClass('nav-dropdown-active');
    });
    $("body").click(function(e){
      $('.nav-dropdown-content').removeClass('nav-dropdown-active');
    });
    $(".nav-dropdown").click(function(e){
      e.stopPropagation();
    });
  });
</script>

<style type="text/css">

/* Theme (user-documented overrideables for nav appearance) */

.distill-site-nav {
  color: rgba(255, 255, 255, 0.8);
  background-color: #0F2E3D;
  font-size: 15px;
  font-weight: 300;
}

.distill-site-nav a {
  color: inherit;
  text-decoration: none;
}

.distill-site-nav a:hover {
  color: white;
}

@media print {
  .distill-site-nav {
    display: none;
  }
}

.distill-site-header {

}

.distill-site-footer {

}


/* Site Header */

.distill-site-header {
  width: 100%;
  box-sizing: border-box;
  z-index: 3;
}

.distill-site-header .nav-left {
  display: inline-block;
  margin-left: 8px;
}

@media screen and (max-width: 768px) {
  .distill-site-header .nav-left {
    margin-left: 0;
  }
}


.distill-site-header .nav-right {
  float: right;
  margin-right: 8px;
}

.distill-site-header a,
.distill-site-header .title {
  display: inline-block;
  text-align: center;
  padding: 14px 10px 14px 10px;
}

.distill-site-header .title {
  font-size: 18px;
  min-width: 150px;
}

.distill-site-header .logo {
  padding: 0;
}

.distill-site-header .logo img {
  display: none;
  max-height: 20px;
  width: auto;
  margin-bottom: -4px;
}

.distill-site-header .nav-image img {
  max-height: 18px;
  width: auto;
  display: inline-block;
  margin-bottom: -3px;
}



@media screen and (min-width: 1000px) {
  .distill-site-header .logo img {
    display: inline-block;
  }
  .distill-site-header .nav-left {
    margin-left: 20px;
  }
  .distill-site-header .nav-right {
    margin-right: 20px;
  }
  .distill-site-header .title {
    padding-left: 12px;
  }
}


.distill-site-header .nav-toggle {
  display: none;
}

.nav-dropdown {
  display: inline-block;
  position: relative;
}

.nav-dropdown .nav-dropbtn {
  border: none;
  outline: none;
  color: rgba(255, 255, 255, 0.8);
  padding: 16px 10px;
  background-color: transparent;
  font-family: inherit;
  font-size: inherit;
  font-weight: inherit;
  margin: 0;
  margin-top: 1px;
  z-index: 2;
}

.nav-dropdown-content {
  display: none;
  position: absolute;
  background-color: white;
  min-width: 200px;
  border: 1px solid rgba(0,0,0,0.15);
  border-radius: 4px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.1);
  z-index: 1;
  margin-top: 2px;
  white-space: nowrap;
  padding-top: 4px;
  padding-bottom: 4px;
}

.nav-dropdown-content hr {
  margin-top: 4px;
  margin-bottom: 4px;
  border: none;
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
}

.nav-dropdown-active {
  display: block;
}

.nav-dropdown-content a, .nav-dropdown-content .nav-dropdown-header {
  color: black;
  padding: 6px 24px;
  text-decoration: none;
  display: block;
  text-align: left;
}

.nav-dropdown-content .nav-dropdown-header {
  display: block;
  padding: 5px 24px;
  padding-bottom: 0;
  text-transform: uppercase;
  font-size: 14px;
  color: #999999;
  white-space: nowrap;
}

.nav-dropdown:hover .nav-dropbtn {
  color: white;
}

.nav-dropdown-content a:hover {
  background-color: #ddd;
  color: black;
}

.nav-right .nav-dropdown-content {
  margin-left: -45%;
  right: 0;
}

@media screen and (max-width: 768px) {
  .distill-site-header a, .distill-site-header .nav-dropdown  {display: none;}
  .distill-site-header a.nav-toggle {
    float: right;
    display: block;
  }
  .distill-site-header .title {
    margin-left: 0;
  }
  .distill-site-header .nav-right {
    margin-right: 0;
  }
  .distill-site-header {
    overflow: hidden;
  }
  .nav-right .nav-dropdown-content {
    margin-left: 0;
  }
}


@media screen and (max-width: 768px) {
  .distill-site-header.responsive {position: relative; min-height: 500px; }
  .distill-site-header.responsive a.nav-toggle {
    position: absolute;
    right: 0;
    top: 0;
  }
  .distill-site-header.responsive a,
  .distill-site-header.responsive .nav-dropdown {
    display: block;
    text-align: left;
  }
  .distill-site-header.responsive .nav-left,
  .distill-site-header.responsive .nav-right {
    width: 100%;
  }
  .distill-site-header.responsive .nav-dropdown {float: none;}
  .distill-site-header.responsive .nav-dropdown-content {position: relative;}
  .distill-site-header.responsive .nav-dropdown .nav-dropbtn {
    display: block;
    width: 100%;
    text-align: left;
  }
}

/* Site Footer */

.distill-site-footer {
  width: 100%;
  overflow: hidden;
  box-sizing: border-box;
  z-index: 3;
  margin-top: 30px;
  padding-top: 30px;
  padding-bottom: 30px;
  text-align: center;
}

/* Headroom */

d-title {
  padding-top: 6rem;
}

@media print {
  d-title {
    padding-top: 4rem;
  }
}

.headroom {
  z-index: 1000;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
}

.headroom--transition {
  transition: all .4s ease-in-out;
}

.headroom--unpinned {
  top: -100px;
}

.headroom--pinned {
  top: 0;
}

</style>

<link href="../../site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet"/>
<link href="../../site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet"/>
<script src="../../site_libs/headroom-0.9.4/headroom.min.js"></script>
<script src="../../site_libs/autocomplete-0.37.1/autocomplete.min.js"></script>
<script src="../../site_libs/fuse-6.4.1/fuse.min.js"></script>

<script type="application/javascript">

function getMeta(metaName) {
  var metas = document.getElementsByTagName('meta');
  for (let i = 0; i < metas.length; i++) {
    if (metas[i].getAttribute('name') === metaName) {
      return metas[i].getAttribute('content');
    }
  }
  return '';
}

function offsetURL(url) {
  var offset = getMeta('distill:offset');
  return offset ? offset + '/' + url : url;
}

function createFuseIndex() {

  // create fuse index
  var options = {
    keys: [
      { name: 'title', weight: 20 },
      { name: 'categories', weight: 15 },
      { name: 'description', weight: 10 },
      { name: 'contents', weight: 5 },
    ],
    ignoreLocation: true,
    threshold: 0
  };
  var fuse = new window.Fuse([], options);

  // fetch the main search.json
  return fetch(offsetURL('search.json'))
    .then(function(response) {
      if (response.status == 200) {
        return response.json().then(function(json) {
          // index main articles
          json.articles.forEach(function(article) {
            fuse.add(article);
          });
          // download collections and index their articles
          return Promise.all(json.collections.map(function(collection) {
            return fetch(offsetURL(collection)).then(function(response) {
              if (response.status === 200) {
                return response.json().then(function(articles) {
                  articles.forEach(function(article) {
                    fuse.add(article);
                  });
                })
              } else {
                return Promise.reject(
                  new Error('Unexpected status from search index request: ' +
                            response.status)
                );
              }
            });
          })).then(function() {
            return fuse;
          });
        });

      } else {
        return Promise.reject(
          new Error('Unexpected status from search index request: ' +
                      response.status)
        );
      }
    });
}

window.document.addEventListener("DOMContentLoaded", function (event) {

  // get search element (bail if we don't have one)
  var searchEl = window.document.getElementById('distill-search');
  if (!searchEl)
    return;

  createFuseIndex()
    .then(function(fuse) {

      // make search box visible
      searchEl.classList.remove('hidden');

      // initialize autocomplete
      var options = {
        autoselect: true,
        hint: false,
        minLength: 2,
      };
      window.autocomplete(searchEl, options, [{
        source: function(query, callback) {
          const searchOptions = {
            isCaseSensitive: false,
            shouldSort: true,
            minMatchCharLength: 2,
            limit: 10,
          };
          var results = fuse.search(query, searchOptions);
          callback(results
            .map(function(result) { return result.item; })
            .filter(function(item) { return !!item.description; })
          );
        },
        templates: {
          suggestion: function(suggestion) {
            var html = `
              <div class="search-item">
                <h3>${suggestion.title}</h3>
                <div class="search-item-description">
                  ${suggestion.description}
                </div>
                <div class="search-item-preview">
                  <img src="${suggestion.preview ? offsetURL(suggestion.preview) : ''}"</img>
                </div>
              </div>
            `;
            return html;
          }
        }
      }]).on('autocomplete:selected', function(event, suggestion) {
        window.location.href = offsetURL(suggestion.path);
      });
      // remove inline display style on autocompleter (we want to
      // manage responsive display via css)
      $('.algolia-autocomplete').css("display", "");
    })
    .catch(function(error) {
      console.log(error);
    });

});

</script>

<style type="text/css">

/* Algolioa Autocomplete */

.algolia-autocomplete {
  display: inline-block;
  margin-left: 10px;
  vertical-align: sub;
  background-color: white;
  color: black;
  padding: 6px;
  padding-top: 8px;
  padding-bottom: 0;
  border-radius: 6px;
  border: 1px #0F2E3D solid;
  width: 180px;
}


@media screen and (max-width: 768px) {
  .distill-site-nav .algolia-autocomplete {
    display: none;
    visibility: hidden;
  }
  .distill-site-nav.responsive .algolia-autocomplete {
    display: inline-block;
    visibility: visible;
  }
  .distill-site-nav.responsive .algolia-autocomplete .aa-dropdown-menu {
    margin-left: 0;
    width: 400px;
    max-height: 400px;
  }
}

.algolia-autocomplete .aa-input, .algolia-autocomplete .aa-hint {
  width: 90%;
  outline: none;
  border: none;
}

.algolia-autocomplete .aa-hint {
  color: #999;
}
.algolia-autocomplete .aa-dropdown-menu {
  width: 550px;
  max-height: 70vh;
  overflow-x: visible;
  overflow-y: scroll;
  padding: 5px;
  margin-top: 3px;
  margin-left: -150px;
  background-color: #fff;
  border-radius: 5px;
  border: 1px solid #999;
  border-top: none;
}

.algolia-autocomplete .aa-dropdown-menu .aa-suggestion {
  cursor: pointer;
  padding: 5px 4px;
  border-bottom: 1px solid #eee;
}

.algolia-autocomplete .aa-dropdown-menu .aa-suggestion:last-of-type {
  border-bottom: none;
  margin-bottom: 2px;
}

.algolia-autocomplete .aa-dropdown-menu .aa-suggestion .search-item {
  overflow: hidden;
  font-size: 0.8em;
  line-height: 1.4em;
}

.algolia-autocomplete .aa-dropdown-menu .aa-suggestion .search-item h3 {
  margin-block-start: 0;
  margin-block-end: 5px;
}

.algolia-autocomplete .aa-dropdown-menu .aa-suggestion .search-item-description {
  display: inline-block;
  overflow: hidden;
  height: 2.8em;
  width: 80%;
  margin-right: 4%;
}

.algolia-autocomplete .aa-dropdown-menu .aa-suggestion .search-item-preview {
  display: inline-block;
  width: 15%;
}

.algolia-autocomplete .aa-dropdown-menu .aa-suggestion .search-item-preview img {
  height: 3em;
  width: auto;
  display: none;
}

.algolia-autocomplete .aa-dropdown-menu .aa-suggestion .search-item-preview img[src] {
  display: initial;
}

.algolia-autocomplete .aa-dropdown-menu .aa-suggestion.aa-cursor {
  background-color: #eee;
}
.algolia-autocomplete .aa-dropdown-menu .aa-suggestion em {
  font-weight: bold;
  font-style: normal;
}

</style>


<!--/radix_placeholder_navigation_in_header-->
  <!--radix_placeholder_distill-->

<style type="text/css">

body {
  background-color: white;
}

.pandoc-table {
  width: 100%;
}

.pandoc-table>caption {
  margin-bottom: 10px;
}

.pandoc-table th:not([align]) {
  text-align: left;
}

.pagedtable-footer {
  font-size: 15px;
}

d-byline .byline {
  grid-template-columns: 2fr 2fr;
}

d-byline .byline h3 {
  margin-block-start: 1.5em;
}

d-byline .byline .authors-affiliations h3 {
  margin-block-start: 0.5em;
}

.authors-affiliations .orcid-id {
  width: 16px;
  height:16px;
  margin-left: 4px;
  margin-right: 4px;
  vertical-align: middle;
  padding-bottom: 2px;
}

d-title .dt-tags {
  margin-top: 1em;
  grid-column: text;
}

.dt-tags .dt-tag {
  text-decoration: none;
  display: inline-block;
  color: rgba(0,0,0,0.6);
  padding: 0em 0.4em;
  margin-right: 0.5em;
  margin-bottom: 0.4em;
  font-size: 70%;
  border: 1px solid rgba(0,0,0,0.2);
  border-radius: 3px;
  text-transform: uppercase;
  font-weight: 500;
}

d-article table.gt_table td,
d-article table.gt_table th {
  border-bottom: none;
}

.html-widget {
  margin-bottom: 2.0em;
}

.l-screen-inset {
  padding-right: 16px;
}

.l-screen .caption {
  margin-left: 10px;
}

.shaded {
  background: rgb(247, 247, 247);
  padding-top: 20px;
  padding-bottom: 20px;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
}

.shaded .html-widget {
  margin-bottom: 0;
  border: 1px solid rgba(0, 0, 0, 0.1);
}

.shaded .shaded-content {
  background: white;
}

.text-output {
  margin-top: 0;
  line-height: 1.5em;
}

.hidden {
  display: none !important;
}

d-article {
  padding-top: 2.5rem;
  padding-bottom: 30px;
}

d-appendix {
  padding-top: 30px;
}

d-article>p>img {
  width: 100%;
}

d-article h2 {
  margin: 1rem 0 1.5rem 0;
}

d-article h3 {
  margin-top: 1.5rem;
}

d-article iframe {
  border: 1px solid rgba(0, 0, 0, 0.1);
  margin-bottom: 2.0em;
  width: 100%;
}

/* Tweak code blocks */

d-article div.sourceCode code,
d-article pre code {
  font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
}

d-article pre,
d-article div.sourceCode,
d-article div.sourceCode pre {
  overflow: auto;
}

d-article div.sourceCode {
  background-color: white;
}

d-article div.sourceCode pre {
  padding-left: 10px;
  font-size: 12px;
  border-left: 2px solid rgba(0,0,0,0.1);
}

d-article pre {
  font-size: 12px;
  color: black;
  background: none;
  margin-top: 0;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.5;

  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

d-article pre a {
  border-bottom: none;
}

d-article pre a:hover {
  border-bottom: none;
  text-decoration: underline;
}

@media(min-width: 768px) {

d-article pre,
d-article div.sourceCode,
d-article div.sourceCode pre {
  overflow: visible !important;
}

d-article div.sourceCode pre {
  padding-left: 18px;
  font-size: 14px;
}

d-article pre {
  font-size: 14px;
}

}

figure img.external {
  background: white;
  border: 1px solid rgba(0, 0, 0, 0.1);
  box-shadow: 0 1px 8px rgba(0, 0, 0, 0.1);
  padding: 18px;
  box-sizing: border-box;
}

/* CSS for d-contents */

.d-contents {
  grid-column: text;
  color: rgba(0,0,0,0.8);
  font-size: 0.9em;
  padding-bottom: 1em;
  margin-bottom: 1em;
  padding-bottom: 0.5em;
  margin-bottom: 1em;
  padding-left: 0.25em;
  justify-self: start;
}

@media(min-width: 1000px) {
  .d-contents.d-contents-float {
    height: 0;
    grid-column-start: 1;
    grid-column-end: 4;
    justify-self: center;
    padding-right: 3em;
    padding-left: 2em;
  }
}

.d-contents nav h3 {
  font-size: 18px;
  margin-top: 0;
  margin-bottom: 1em;
}

.d-contents li {
  list-style-type: none
}

.d-contents nav > ul {
  padding-left: 0;
}

.d-contents ul {
  padding-left: 1em
}

.d-contents nav ul li {
  margin-top: 0.6em;
  margin-bottom: 0.2em;
}

.d-contents nav a {
  font-size: 13px;
  border-bottom: none;
  text-decoration: none
  color: rgba(0, 0, 0, 0.8);
}

.d-contents nav a:hover {
  text-decoration: underline solid rgba(0, 0, 0, 0.6)
}

.d-contents nav > ul > li > a {
  font-weight: 600;
}

.d-contents nav > ul > li > ul {
  font-weight: inherit;
}

.d-contents nav > ul > li > ul > li {
  margin-top: 0.2em;
}


.d-contents nav ul {
  margin-top: 0;
  margin-bottom: 0.25em;
}

.d-article-with-toc h2:nth-child(2) {
  margin-top: 0;
}


/* Figure */

.figure {
  position: relative;
  margin-bottom: 2.5em;
  margin-top: 1.5em;
}

.figure img {
  width: 100%;
}

.figure .caption {
  color: rgba(0, 0, 0, 0.6);
  font-size: 12px;
  line-height: 1.5em;
}

.figure img.external {
  background: white;
  border: 1px solid rgba(0, 0, 0, 0.1);
  box-shadow: 0 1px 8px rgba(0, 0, 0, 0.1);
  padding: 18px;
  box-sizing: border-box;
}

.figure .caption a {
  color: rgba(0, 0, 0, 0.6);
}

.figure .caption b,
.figure .caption strong, {
  font-weight: 600;
  color: rgba(0, 0, 0, 1.0);
}

/* Citations */

d-article .citation {
  color: inherit;
  cursor: inherit;
}

div.hanging-indent{
  margin-left: 1em; text-indent: -1em;
}


/* Tweak 1000px media break to show more text */

@media(min-width: 1000px) {
  .base-grid,
  distill-header,
  d-title,
  d-abstract,
  d-article,
  d-appendix,
  distill-appendix,
  d-byline,
  d-footnote-list,
  d-citation-list,
  distill-footer {
    grid-template-columns: [screen-start] 1fr [page-start kicker-start] 80px [middle-start] 50px [text-start kicker-end] 65px 65px 65px 65px 65px 65px 65px 65px [text-end gutter-start] 65px [middle-end] 65px [page-end gutter-end] 1fr [screen-end];
    grid-column-gap: 16px;
  }

  .grid {
    grid-column-gap: 16px;
  }

  d-article {
    font-size: 1.06rem;
    line-height: 1.7em;
  }
  figure .caption, .figure .caption, figure figcaption {
    font-size: 13px;
  }
}

@media(min-width: 1180px) {
  .base-grid,
  distill-header,
  d-title,
  d-abstract,
  d-article,
  d-appendix,
  distill-appendix,
  d-byline,
  d-footnote-list,
  d-citation-list,
  distill-footer {
    grid-template-columns: [screen-start] 1fr [page-start kicker-start] 60px [middle-start] 60px [text-start kicker-end] 60px 60px 60px 60px 60px 60px 60px 60px [text-end gutter-start] 60px [middle-end] 60px [page-end gutter-end] 1fr [screen-end];
    grid-column-gap: 32px;
  }

  .grid {
    grid-column-gap: 32px;
  }
}


/* Get the citation styles for the appendix (not auto-injected on render since
   we do our own rendering of the citation appendix) */

d-appendix .citation-appendix,
.d-appendix .citation-appendix {
  font-size: 11px;
  line-height: 15px;
  border-left: 1px solid rgba(0, 0, 0, 0.1);
  padding-left: 18px;
  border: 1px solid rgba(0,0,0,0.1);
  background: rgba(0, 0, 0, 0.02);
  padding: 10px 18px;
  border-radius: 3px;
  color: rgba(150, 150, 150, 1);
  overflow: hidden;
  margin-top: -12px;
  white-space: pre-wrap;
  word-wrap: break-word;
}

/* Include appendix styles here so they can be overridden */

d-appendix {
  contain: layout style;
  font-size: 0.8em;
  line-height: 1.7em;
  margin-top: 60px;
  margin-bottom: 0;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
  color: rgba(0,0,0,0.5);
  padding-top: 60px;
  padding-bottom: 48px;
}

d-appendix h3 {
  grid-column: page-start / text-start;
  font-size: 15px;
  font-weight: 500;
  margin-top: 1em;
  margin-bottom: 0;
  color: rgba(0,0,0,0.65);
}

d-appendix h3 + * {
  margin-top: 1em;
}

d-appendix ol {
  padding: 0 0 0 15px;
}

@media (min-width: 768px) {
  d-appendix ol {
    padding: 0 0 0 30px;
    margin-left: -30px;
  }
}

d-appendix li {
  margin-bottom: 1em;
}

d-appendix a {
  color: rgba(0, 0, 0, 0.6);
}

d-appendix > * {
  grid-column: text;
}

d-appendix > d-footnote-list,
d-appendix > d-citation-list,
d-appendix > distill-appendix {
  grid-column: screen;
}

/* Include footnote styles here so they can be overridden */

d-footnote-list {
  contain: layout style;
}

d-footnote-list > * {
  grid-column: text;
}

d-footnote-list a.footnote-backlink {
  color: rgba(0,0,0,0.3);
  padding-left: 0.5em;
}



/* Anchor.js */

.anchorjs-link {
  /*transition: all .25s linear; */
  text-decoration: none;
  border-bottom: none;
}
*:hover > .anchorjs-link {
  margin-left: -1.125em !important;
  text-decoration: none;
  border-bottom: none;
}

/* Social footer */

.social_footer {
  margin-top: 30px;
  margin-bottom: 0;
  color: rgba(0,0,0,0.67);
}

.disqus-comments {
  margin-right: 30px;
}

.disqus-comment-count {
  border-bottom: 1px solid rgba(0, 0, 0, 0.4);
  cursor: pointer;
}

#disqus_thread {
  margin-top: 30px;
}

.article-sharing a {
  border-bottom: none;
  margin-right: 8px;
}

.article-sharing a:hover {
  border-bottom: none;
}

.sidebar-section.subscribe {
  font-size: 12px;
  line-height: 1.6em;
}

.subscribe p {
  margin-bottom: 0.5em;
}


.article-footer .subscribe {
  font-size: 15px;
  margin-top: 45px;
}


.sidebar-section.custom {
  font-size: 12px;
  line-height: 1.6em;
}

.custom p {
  margin-bottom: 0.5em;
}

/* Styles for listing layout (hide title) */
.layout-listing d-title, .layout-listing .d-title {
  display: none;
}

/* Styles for posts lists (not auto-injected) */


.posts-with-sidebar {
  padding-left: 45px;
  padding-right: 45px;
}

.posts-list .description h2,
.posts-list .description p {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", Arial, sans-serif;
}

.posts-list .description h2 {
  font-weight: 700;
  border-bottom: none;
  padding-bottom: 0;
}

.posts-list h2.post-tag {
  border-bottom: 1px solid rgba(0, 0, 0, 0.2);
  padding-bottom: 12px;
}
.posts-list {
  margin-top: 60px;
  margin-bottom: 24px;
}

.posts-list .post-preview {
  text-decoration: none;
  overflow: hidden;
  display: block;
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
  padding: 24px 0;
}

.post-preview-last {
  border-bottom: none !important;
}

.posts-list .posts-list-caption {
  grid-column: screen;
  font-weight: 400;
}

.posts-list .post-preview h2 {
  margin: 0 0 6px 0;
  line-height: 1.2em;
  font-style: normal;
  font-size: 24px;
}

.posts-list .post-preview p {
  margin: 0 0 12px 0;
  line-height: 1.4em;
  font-size: 16px;
}

.posts-list .post-preview .thumbnail {
  box-sizing: border-box;
  margin-bottom: 24px;
  position: relative;
  max-width: 500px;
}
.posts-list .post-preview img {
  width: 100%;
  display: block;
}

.posts-list .metadata {
  font-size: 12px;
  line-height: 1.4em;
  margin-bottom: 18px;
}

.posts-list .metadata > * {
  display: inline-block;
}

.posts-list .metadata .publishedDate {
  margin-right: 2em;
}

.posts-list .metadata .dt-authors {
  display: block;
  margin-top: 0.3em;
  margin-right: 2em;
}

.posts-list .dt-tags {
  display: block;
  line-height: 1em;
}

.posts-list .dt-tags .dt-tag {
  display: inline-block;
  color: rgba(0,0,0,0.6);
  padding: 0.3em 0.4em;
  margin-right: 0.2em;
  margin-bottom: 0.4em;
  font-size: 60%;
  border: 1px solid rgba(0,0,0,0.2);
  border-radius: 3px;
  text-transform: uppercase;
  font-weight: 500;
}

.posts-list img {
  opacity: 1;
}

.posts-list img[data-src] {
  opacity: 0;
}

.posts-more {
  clear: both;
}


.posts-sidebar {
  font-size: 16px;
}

.posts-sidebar h3 {
  font-size: 16px;
  margin-top: 0;
  margin-bottom: 0.5em;
  font-weight: 400;
  text-transform: uppercase;
}

.sidebar-section {
  margin-bottom: 30px;
}

.categories ul {
  list-style-type: none;
  margin: 0;
  padding: 0;
}

.categories li {
  color: rgba(0, 0, 0, 0.8);
  margin-bottom: 0;
}

.categories li>a {
  border-bottom: none;
}

.categories li>a:hover {
  border-bottom: 1px solid rgba(0, 0, 0, 0.4);
}

.categories .active {
  font-weight: 600;
}

.categories .category-count {
  color: rgba(0, 0, 0, 0.4);
}


@media(min-width: 768px) {
  .posts-list .post-preview h2 {
    font-size: 26px;
  }
  .posts-list .post-preview .thumbnail {
    float: right;
    width: 30%;
    margin-bottom: 0;
  }
  .posts-list .post-preview .description {
    float: left;
    width: 45%;
  }
  .posts-list .post-preview .metadata {
    float: left;
    width: 20%;
    margin-top: 8px;
  }
  .posts-list .post-preview p {
    margin: 0 0 12px 0;
    line-height: 1.5em;
    font-size: 16px;
  }
  .posts-with-sidebar .posts-list {
    float: left;
    width: 75%;
  }
  .posts-with-sidebar .posts-sidebar {
    float: right;
    width: 20%;
    margin-top: 60px;
    padding-top: 24px;
    padding-bottom: 24px;
  }
}


/* Improve display for browsers without grid (IE/Edge <= 15) */

.downlevel {
  line-height: 1.6em;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", Arial, sans-serif;
  margin: 0;
}

.downlevel .d-title {
  padding-top: 6rem;
  padding-bottom: 1.5rem;
}

.downlevel .d-title h1 {
  font-size: 50px;
  font-weight: 700;
  line-height: 1.1em;
  margin: 0 0 0.5rem;
}

.downlevel .d-title p {
  font-weight: 300;
  font-size: 1.2rem;
  line-height: 1.55em;
  margin-top: 0;
}

.downlevel .d-byline {
  padding-top: 0.8em;
  padding-bottom: 0.8em;
  font-size: 0.8rem;
  line-height: 1.8em;
}

.downlevel .section-separator {
  border: none;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
}

.downlevel .d-article {
  font-size: 1.06rem;
  line-height: 1.7em;
  padding-top: 1rem;
  padding-bottom: 2rem;
}


.downlevel .d-appendix {
  padding-left: 0;
  padding-right: 0;
  max-width: none;
  font-size: 0.8em;
  line-height: 1.7em;
  margin-bottom: 0;
  color: rgba(0,0,0,0.5);
  padding-top: 40px;
  padding-bottom: 48px;
}

.downlevel .footnotes ol {
  padding-left: 13px;
}

.downlevel .base-grid,
.downlevel .distill-header,
.downlevel .d-title,
.downlevel .d-abstract,
.downlevel .d-article,
.downlevel .d-appendix,
.downlevel .distill-appendix,
.downlevel .d-byline,
.downlevel .d-footnote-list,
.downlevel .d-citation-list,
.downlevel .distill-footer,
.downlevel .appendix-bottom,
.downlevel .posts-container {
  padding-left: 40px;
  padding-right: 40px;
}

@media(min-width: 768px) {
  .downlevel .base-grid,
  .downlevel .distill-header,
  .downlevel .d-title,
  .downlevel .d-abstract,
  .downlevel .d-article,
  .downlevel .d-appendix,
  .downlevel .distill-appendix,
  .downlevel .d-byline,
  .downlevel .d-footnote-list,
  .downlevel .d-citation-list,
  .downlevel .distill-footer,
  .downlevel .appendix-bottom,
  .downlevel .posts-container {
  padding-left: 150px;
  padding-right: 150px;
  max-width: 900px;
}
}

.downlevel pre code {
  display: block;
  border-left: 2px solid rgba(0, 0, 0, .1);
  padding: 0 0 0 20px;
  font-size: 14px;
}

.downlevel code, .downlevel pre {
  color: black;
  background: none;
  font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.5;

  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

.downlevel .posts-list .post-preview {
  color: inherit;
}



</style>

<script type="application/javascript">

function is_downlevel_browser() {
  if (bowser.isUnsupportedBrowser({ msie: "12", msedge: "16"},
                                 window.navigator.userAgent)) {
    return true;
  } else {
    return window.load_distill_framework === undefined;
  }
}

// show body when load is complete
function on_load_complete() {

  // add anchors
  if (window.anchors) {
    window.anchors.options.placement = 'left';
    window.anchors.add('d-article > h2, d-article > h3, d-article > h4, d-article > h5');
  }


  // set body to visible
  document.body.style.visibility = 'visible';

  // force redraw for leaflet widgets
  if (window.HTMLWidgets) {
    var maps = window.HTMLWidgets.findAll(".leaflet");
    $.each(maps, function(i, el) {
      var map = this.getMap();
      map.invalidateSize();
      map.eachLayer(function(layer) {
        if (layer instanceof L.TileLayer)
          layer.redraw();
      });
    });
  }

  // trigger 'shown' so htmlwidgets resize
  $('d-article').trigger('shown');
}

function init_distill() {

  init_common();

  // create front matter
  var front_matter = $('<d-front-matter></d-front-matter>');
  $('#distill-front-matter').wrap(front_matter);

  // create d-title
  $('.d-title').changeElementType('d-title');

  // create d-byline
  var byline = $('<d-byline></d-byline>');
  $('.d-byline').replaceWith(byline);

  // create d-article
  var article = $('<d-article></d-article>');
  $('.d-article').wrap(article).children().unwrap();

  // move posts container into article
  $('.posts-container').appendTo($('d-article'));

  // create d-appendix
  $('.d-appendix').changeElementType('d-appendix');

  // flag indicating that we have appendix items
  var appendix = $('.appendix-bottom').children('h3').length > 0;

  // replace footnotes with <d-footnote>
  $('.footnote-ref').each(function(i, val) {
    appendix = true;
    var href = $(this).attr('href');
    var id = href.replace('#', '');
    var fn = $('#' + id);
    var fn_p = $('#' + id + '>p');
    fn_p.find('.footnote-back').remove();
    var text = fn_p.html();
    var dtfn = $('<d-footnote></d-footnote>');
    dtfn.html(text);
    $(this).replaceWith(dtfn);
  });
  // remove footnotes
  $('.footnotes').remove();

  // move refs into #references-listing
  $('#references-listing').replaceWith($('#refs'));

  $('h1.appendix, h2.appendix').each(function(i, val) {
    $(this).changeElementType('h3');
  });
  $('h3.appendix').each(function(i, val) {
    var id = $(this).attr('id');
    $('.d-contents a[href="#' + id + '"]').parent().remove();
    appendix = true;
    $(this).nextUntil($('h1, h2, h3')).addBack().appendTo($('d-appendix'));
  });

  // show d-appendix if we have appendix content
  $("d-appendix").css('display', appendix ? 'grid' : 'none');

  // localize layout chunks to just output
  $('.layout-chunk').each(function(i, val) {

    // capture layout
    var layout = $(this).attr('data-layout');

    // apply layout to markdown level block elements
    var elements = $(this).children().not('div.sourceCode, pre, script');
    elements.each(function(i, el) {
      var layout_div = $('<div class="' + layout + '"></div>');
      if (layout_div.hasClass('shaded')) {
        var shaded_content = $('<div class="shaded-content"></div>');
        $(this).wrap(shaded_content);
        $(this).parent().wrap(layout_div);
      } else {
        $(this).wrap(layout_div);
      }
    });


    // unwrap the layout-chunk div
    $(this).children().unwrap();
  });

  // remove code block used to force  highlighting css
  $('.distill-force-highlighting-css').parent().remove();

  // remove empty line numbers inserted by pandoc when using a
  // custom syntax highlighting theme
  $('code.sourceCode a:empty').remove();

  // load distill framework
  load_distill_framework();

  // wait for window.distillRunlevel == 4 to do post processing
  function distill_post_process() {

    if (!window.distillRunlevel || window.distillRunlevel < 4)
      return;

    // hide author/affiliations entirely if we have no authors
    var front_matter = JSON.parse($("#distill-front-matter").html());
    var have_authors = front_matter.authors && front_matter.authors.length > 0;
    if (!have_authors)
      $('d-byline').addClass('hidden');

    // article with toc class
    $('.d-contents').parent().addClass('d-article-with-toc');

    // strip links that point to #
    $('.authors-affiliations').find('a[href="#"]').removeAttr('href');

    // add orcid ids
    $('.authors-affiliations').find('.author').each(function(i, el) {
      var orcid_id = front_matter.authors[i].orcidID;
      if (orcid_id) {
        var a = $('<a></a>');
        a.attr('href', 'https://orcid.org/' + orcid_id);
        var img = $('<img></img>');
        img.addClass('orcid-id');
        img.attr('alt', 'ORCID ID');
        img.attr('src','data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg==');
        a.append(img);
        $(this).append(a);
      }
    });

    // hide elements of author/affiliations grid that have no value
    function hide_byline_column(caption) {
      $('d-byline').find('h3:contains("' + caption + '")').parent().css('visibility', 'hidden');
    }

    // affiliations
    var have_affiliations = false;
    for (var i = 0; i<front_matter.authors.length; ++i) {
      var author = front_matter.authors[i];
      if (author.affiliation !== "&nbsp;") {
        have_affiliations = true;
        break;
      }
    }
    if (!have_affiliations)
      $('d-byline').find('h3:contains("Affiliations")').css('visibility', 'hidden');

    // published date
    if (!front_matter.publishedDate)
      hide_byline_column("Published");

    // document object identifier
    var doi = $('d-byline').find('h3:contains("DOI")');
    var doi_p = doi.next().empty();
    if (!front_matter.doi) {
      // if we have a citation and valid citationText then link to that
      if ($('#citation').length > 0 && front_matter.citationText) {
        doi.html('Citation');
        $('<a href="#citation"></a>')
          .text(front_matter.citationText)
          .appendTo(doi_p);
      } else {
        hide_byline_column("DOI");
      }
    } else {
      $('<a></a>')
         .attr('href', "https://doi.org/" + front_matter.doi)
         .html(front_matter.doi)
         .appendTo(doi_p);
    }

     // change plural form of authors/affiliations
    if (front_matter.authors.length === 1) {
      var grid = $('.authors-affiliations');
      grid.children('h3:contains("Authors")').text('Author');
      grid.children('h3:contains("Affiliations")').text('Affiliation');
    }

    // remove d-appendix and d-footnote-list local styles
    $('d-appendix > style:first-child').remove();
    $('d-footnote-list > style:first-child').remove();

    // move appendix-bottom entries to the bottom
    $('.appendix-bottom').appendTo('d-appendix').children().unwrap();
    $('.appendix-bottom').remove();

    // clear polling timer
    clearInterval(tid);

    // show body now that everything is ready
    on_load_complete();
  }

  var tid = setInterval(distill_post_process, 50);
  distill_post_process();

}

function init_downlevel() {

  init_common();

   // insert hr after d-title
  $('.d-title').after($('<hr class="section-separator"/>'));

  // check if we have authors
  var front_matter = JSON.parse($("#distill-front-matter").html());
  var have_authors = front_matter.authors && front_matter.authors.length > 0;

  // manage byline/border
  if (!have_authors)
    $('.d-byline').remove();
  $('.d-byline').after($('<hr class="section-separator"/>'));
  $('.d-byline a').remove();

  // remove toc
  $('.d-contents').remove();

  // move appendix elements
  $('h1.appendix, h2.appendix').each(function(i, val) {
    $(this).changeElementType('h3');
  });
  $('h3.appendix').each(function(i, val) {
    $(this).nextUntil($('h1, h2, h3')).addBack().appendTo($('.d-appendix'));
  });


  // inject headers into references and footnotes
  var refs_header = $('<h3></h3>');
  refs_header.text('References');
  $('#refs').prepend(refs_header);

  var footnotes_header = $('<h3></h3');
  footnotes_header.text('Footnotes');
  $('.footnotes').children('hr').first().replaceWith(footnotes_header);

  // move appendix-bottom entries to the bottom
  $('.appendix-bottom').appendTo('.d-appendix').children().unwrap();
  $('.appendix-bottom').remove();

  // remove appendix if it's empty
  if ($('.d-appendix').children().length === 0)
    $('.d-appendix').remove();

  // prepend separator above appendix
  $('.d-appendix').before($('<hr class="section-separator" style="clear: both"/>'));

  // trim code
  $('pre>code').each(function(i, val) {
    $(this).html($.trim($(this).html()));
  });

  // move posts-container right before article
  $('.posts-container').insertBefore($('.d-article'));

  $('body').addClass('downlevel');

  on_load_complete();
}


function init_common() {

  // jquery plugin to change element types
  (function($) {
    $.fn.changeElementType = function(newType) {
      var attrs = {};

      $.each(this[0].attributes, function(idx, attr) {
        attrs[attr.nodeName] = attr.nodeValue;
      });

      this.replaceWith(function() {
        return $("<" + newType + "/>", attrs).append($(this).contents());
      });
    };
  })(jQuery);

  // prevent underline for linked images
  $('a > img').parent().css({'border-bottom' : 'none'});

  // mark non-body figures created by knitr chunks as 100% width
  $('.layout-chunk').each(function(i, val) {
    var figures = $(this).find('img, .html-widget');
    if ($(this).attr('data-layout') !== "l-body") {
      figures.css('width', '100%');
    } else {
      figures.css('max-width', '100%');
      figures.filter("[width]").each(function(i, val) {
        var fig = $(this);
        fig.css('width', fig.attr('width') + 'px');
      });

    }
  });

  // auto-append index.html to post-preview links in file: protocol
  // and in rstudio ide preview
  $('.post-preview').each(function(i, val) {
    if (window.location.protocol === "file:")
      $(this).attr('href', $(this).attr('href') + "index.html");
  });

  // get rid of index.html references in header
  if (window.location.protocol !== "file:") {
    $('.distill-site-header a[href]').each(function(i,val) {
      $(this).attr('href', $(this).attr('href').replace("index.html", "./"));
    });
  }

  // add class to pandoc style tables
  $('tr.header').parent('thead').parent('table').addClass('pandoc-table');
  $('.kable-table').children('table').addClass('pandoc-table');

  // add figcaption style to table captions
  $('caption').parent('table').addClass("figcaption");

  // initialize posts list
  if (window.init_posts_list)
    window.init_posts_list();

  // implmement disqus comment link
  $('.disqus-comment-count').click(function() {
    window.headroom_prevent_pin = true;
    $('#disqus_thread').toggleClass('hidden');
    if (!$('#disqus_thread').hasClass('hidden')) {
      var offset = $(this).offset();
      $(window).resize();
      $('html, body').animate({
        scrollTop: offset.top - 35
      });
    }
  });
}

document.addEventListener('DOMContentLoaded', function() {
  if (is_downlevel_browser())
    init_downlevel();
  else
    window.addEventListener('WebComponentsReady', init_distill);
});

</script>

<!--/radix_placeholder_distill-->
  <script src="../../site_libs/header-attrs-2.3/header-attrs.js"></script>
  <script src="../../site_libs/jquery-1.11.3/jquery.min.js"></script>
  <script src="../../site_libs/bowser-1.9.3/bowser.min.js"></script>
  <script src="../../site_libs/webcomponents-2.0.0/webcomponents.js"></script>
  <script src="../../site_libs/distill-2.2.21/template.v2.js"></script>
  <!--radix_placeholder_site_in_header-->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-176408251-2"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-176408251-2');
</script>
<style type="text/css">
d-article div.sourceCode pre {
  overflow-x: scroll !important;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f6f8fa;
  border-left: 0;
}

.distill-site-nav {
  color: #ffffff;
  font-weight: 400;
  background: #24292e;
  border-bottom: 2px solid #DECF40;
  -webkit-box-shadow: 1px 1px 18px #4d4d4d;
  -moz-box-shadow: 1px 1px 18px #4d4d4d;
  box-shadow: 1px 1px 18px #4d4d4d;
}

.distill-site-nav a:hover {
  color: white;
  font-weight: 700;
}

d-title {
  background: #575757;
  color: white;
}

.distill-site-footer {
  border-top: 2px solid #DECF40;
  border-bottom: 0;
}

</style>
<!--/radix_placeholder_site_in_header-->


</head>

<body>

<!--radix_placeholder_front_matter-->

<script id="distill-front-matter" type="text/json">
{"title":"Player Density and Completion Surface Estimates","description":"Methods for modeling density estimates and expected completion percentages across the football field for individual players.","authors":[{"author":"Ethan Douglas","authorURL":"https://twitter.com/ChiefsAnalytics","affiliation":"&nbsp;","affiliationURL":"#","orcidID":""}],"publishedDate":"2020-08-29T00:00:00.000+00:00","citationText":"Douglas, 2020"}
</script>

<!--/radix_placeholder_front_matter-->
<!--radix_placeholder_navigation_before_body-->
<header class="header header--fixed" role="banner">
<nav class="distill-site-nav distill-site-header">
<div class="nav-left">
<a class="logo" href="https://twitter.com/Open_Source_FB">
<img src="../../logo.png" alt="Logo"/>
</a>
<a href="../../index.html" class="title">Open Source Football</a>
<input id="distill-search" class="nav-search hidden" type="text" placeholder="Search..."/>
</div>
<div class="nav-right">
<a href="../../index.html">Home</a>
<a href="../../contributing.html">Contributing</a>
<a href="../../contributors_list.html">Authors</a>
<a href="../../about.html">About</a>
<a href="https://github.com/mrcaseb/open-source-football">
<i class="fa fa-github" aria-hidden="true"></i>
</a>
<a href="../../index.xml">
<i class="fa fa-rss" aria-hidden="true"></i>
</a>
<a href="javascript:void(0);" class="nav-toggle">&#9776;</a>
</div>
</nav>
</header>
<!--/radix_placeholder_navigation_before_body-->
<!--radix_placeholder_site_before_body-->
<!--/radix_placeholder_site_before_body-->

<div class="d-title">
<h1>Player Density and Completion Surface Estimates</h1>
<p><p>Methods for modeling density estimates and expected completion percentages across the football field for individual players.</p></p>
</div>

<div class="d-byline">
  Ethan Douglas <a href="https://twitter.com/ChiefsAnalytics" class="uri">https://twitter.com/ChiefsAnalytics</a> 
  
<br/>08-29-2020
</div>

<div class="d-article">
<h3 class="d-toc-header">Table of Contents</h3>
<nav class="d-toc" id="TOC">
<ul>
<li><a href="#density-estimates-and-expected-completion-surfaces">Density Estimates and Expected Completion Surfaces</a>
<ul>
<li><a href="#density-estimates">Density Estimates</a></li>
<li><a href="#expected-completion-surfaces">Expected Completion Surfaces</a></li>
</ul></li>
</ul>
</nav>
<hr class="d-toc-separator"/>
<h1 id="density-estimates-and-expected-completion-surfaces">Density Estimates and Expected Completion Surfaces</h1>
<p>In this post I will cover</p>
<ul>
<li><p>Using the scipy library to create your own kernel density estimator</p></li>
<li><p>Using this estimator to easily compare the densities of two players</p></li>
<li><p>Modeling the expected completion % of a pass, and plotting these probabilities as a surface over the field</p></li>
<li><p>Modeling the expected completion % of a pass for a particular player or team, and comparing that to the rest of the league</p></li>
</ul>
<p>In my <a href="https://www.opensourcefootball.com/posts/2020-08-22-nfl-pass-location-visualization/">last post</a> I gave some examples of how you can use the seaborn library in python to plot heat maps of NFL passing locations. For this post Im going to pick right back up where we left off - performing kernal density estimates (KDEs) with the scipy library rather than relying on the seaborn library. The advantage here is that we can get an estimate of the density of the passes, and then slice and dice that estimate however we want, performing calculations on the output. Ill show you why that can be useful.</p>
<p>As a reminder, we wanted to compare the densities of Patrick Mahomes and Derek Carr. Our graph worked fine - but what if we wanted to overlay those densities, so that the true differences were more apparent? Thats where the more manual (but still very much not manual) KDE comes in. One important note before we begin: while Ive since modified the code a bit, as I mentioned in the previous post this Next Gen Stats scraper was first created by <a href="https://arxiv.org/abs/1906.03339">Sarah Mallepalle et al.(2019)</a>. I cannot recommend reading this paper enough!</p>
<h2 id="density-estimates">Density Estimates</h2>
<div class="layout-chunk" data-layout="l-body">
<pre class="python"><code>
#imports
import pandas as pd
import seaborn as sns
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
from scipy import stats
from pygam import LogisticGAM, s, f, te
#I&#39;m surpressing warnings here because the PyGAM library warns you that the p-values are smaller than likely, which I am not concerned with.
import warnings
warnings.filterwarnings(&quot;ignore&quot;)
#load passing location data
df = pd.read_csv(&#39;https://raw.githubusercontent.com/ArrowheadAnalytics/next-gen-scrapy-2.0/master/pass_and_game_data.csv&#39;, low_memory=False)
#There&#39;s an additional index row we don&#39;t need, so I am getting rid of it here
df = df.iloc[0:,1:]
df.dropna(inplace=True)</code></pre>
</div>
<p>What were going to do here is create a helper function, which will allow is to perform the kernal density. The key to making these KDEs comparable between players is the grid size. By keeping these constant between players we are comparing apples to apples.</p>
<div class="layout-chunk" data-layout="l-body">
<pre class="python"><code>
#Function that will help us get our data in the right shape every time we want to do this estimate
def kde_helper(df,name):
    &#39;&#39;&#39;Function to get data in the correct form for the KDE function
    inputs: dataframe, player name
    output: KDE applied to mesh grid, ready for plotting&#39;&#39;&#39;
    #Creating a mesh grid dividing each yard in half (so 4 units in a square yard),
    #between the boundaries of the x and y coordinates (the min and max of our data) supplied.
    m1 = df[&#39;x_coord&#39;].loc[(df[&#39;name&#39;].str.contains(name))]
    m2 = df[&#39;y_coord&#39;].loc[(df[&#39;name&#39;].str.contains(name))]
    #By using the same size grid each time we perform these estimates, we can make direct apples to apples comparisons between players. 
    #What we&#39;re doing with this line is creating a &quot;mesh grid&quot; (think matrix) which we&#39;ll eventually evaluate the KDE on
    X, Y = np.mgrid[-30:30:121j, -10:60:141j]
    #flatten and stack these grids, giving a 2xn array of positions where n = 121*141 (the # of steps for each direction)
    #Basically what we are getting here is a &quot;coordinate&quot; for every single step we&#39;ve created.
    #We start the x min at -30, so there will be 141 -30s - because -30 will be paired with every step we&#39;ve created in the y direction.
    positions = np.vstack([X.ravel(), Y.ravel()])
    #Stack the values we care about in a 2xm array (basically transposing them here), where m is just the length of our supplied data
    values = np.vstack([m1, m2])
    #Perform the kernel estimation on the values we care about - you can think of this as &quot;training&quot; the kernel estimator
    kernel = stats.gaussian_kde(values)
    #Generate probabilities at the positions specified, transpose them, and put them back into the grid shape for plotting
    Z = np.reshape(kernel(positions).T, X.shape)
    return Z</code></pre>
</div>
<p>Now that weve got the helper function, we can try it out!</p>
<div class="layout-chunk" data-layout="l-body">
<pre class="python"><code>
#We&#39;ll start with Mahomes
name=&#39;Mahomes&#39;
mahomes_kde = kde_helper(df,name)
#That was easy! Now Carr
name=&#39;Carr&#39;
carr_kde = kde_helper(df,name)</code></pre>
</div>
<p>So weve got our two estimates. There are different ways you can play around with these estimates to find insights but what Im going to focus on is the difference between the two estimates. The nice thing is this is really easy to do, you just subtract them.</p>
<div class="layout-chunk" data-layout="l-body">
<pre class="python"><code>
#again - simple!
diff_kde = mahomes_kde - carr_kde</code></pre>
</div>
<p>The plotting here is a bit different than what we did in the previous post. Well be using matplotlibs imshow() function, which is what you use to display image files like JPEGs. imshow accepts a matrix as an input, either MxN (what we have with our kde - a colormap), MxNx3 (how a traditional picture is stored - RGB values for each pixel location), or MxNx4 (adding an additional layer of our matrix to control the transparency level)</p>
<div class="layout-chunk" data-layout="1-page">
<pre class="python"><code>
#Set our style
plt.style.use(&#39;seaborn-talk&#39;)

fig, ax1 =plt.subplots(1,1)

#This line is where the magic happens. Because of the way we performed the KDE, we have to rotate our data 270 degrees to plot in the orientation we want (np.rot90)
#Next, we want to make sure a pixel in the left direction is the same coordinate distance as a pixel in the vertical direction, so we set aspect to equal
#The extent is setting the coordinate system of the displayed image (along with the &quot;origin&quot; parameter). This is necessary to make sure that what we are indicating is the 20 yard line shows up as the 20 yardline in the pic
#Next, we want to normalize our colormap so that 0 is in the exact middle of the colormap. We can do this by having vmin and vmax have the same absolute value
#Lastly, we set the colormap parameter. I like &quot;diverging&quot; colormaps that have white in the middle for comparison plots, so it is clear which values are positive, negative, and 0.
plt.imshow(np.fliplr(np.rot90(diff_kde,3)),
           origin=&#39;lower&#39;, aspect=&#39;equal&#39;,
           extent=[-30, 30, -10, 60],
           norm = mpl.colors.Normalize(vmin=-0.0005, vmax=0.0005),
           cmap=&#39;RdBu_r&#39;)
#Add a &quot;colorbar&quot;, a scale so people know what color represents what
cbar = plt.colorbar()
cbar.set_label(&quot;\nMahomes (Red) - Carr (Blue) passing densities&quot;)
#We don&#39;t really care about the values here, only the relative differences. 
#The values will change depending on how small we slice up our field. So, I only want to show the viewer what 0 is.
cbar.set_ticks([0])
#Set title, remove ticks and labels
ax1.set_title(&#39;Mahomes vs Carr - NFL Passing Densities&#39;)
ax1.set_xlabel(&#39;&#39;)
ax1.set_xticks([])</code></pre>
<pre class="python"><code>
ax1.set_yticks([])</code></pre>
<pre class="python"><code>
ax1.set_ylabel(&#39;&#39;)

#Remove any part of the plot that is out of bounds
ax1.set_xlim(-53.3333/2, 53.3333/2)</code></pre>
<pre class="python"><code>
ax1.set_ylim(-10,60)


#Plot all of the field markings (line of scrimmage, hash marks, etc.)</code></pre>
<pre class="python"><code>
for j in range(-10,60,1):
    ax1.annotate(&#39;--&#39;, (-3.1,j-0.5),
                 ha=&#39;center&#39;,fontsize =10)
    ax1.annotate(&#39;--&#39;, (3.1,j-0.5),
                 ha=&#39;center&#39;,fontsize =10)
    
for i in range(-10,60,5):
    ax1.axhline(i,c=&#39;k&#39;,ls=&#39;-&#39;,alpha=0.5, lw=1.5)
    
for i in range(-10,60,10):
    ax1.axhline(i,c=&#39;k&#39;,ls=&#39;-&#39;,alpha=0.7, lw=1.5)
    
for i in range(10,60-1,10):
    ax1.annotate(str(i), (-12.88,i-1.15),
            ha=&#39;center&#39;,fontsize =15,
                rotation=270)
    
    ax1.annotate(str(i), (12.88,i-0.65),
            ha=&#39;center&#39;,fontsize =15,
                rotation=90)

ax1.annotate(&#39;Line of Scrimmage&#39;, (16,0),
             textcoords=&quot;offset points&quot;, # how to position the text
                 xytext=(0,5), # distance from text to points (x,y)
                 ha=&#39;center&#39;,fontsize = 9) # horizontal alignment can be left, right or center
</code></pre>
<p><img src="player-density-and-completion-surface-estimates_files/figure-html5/plotting-1.png" width="998" /></p>
</div>
<p>This plot lets us see the differences in the densities between the two players, but theres a lot of color there. Depending on the device youre viewing this chart on, it may be hard to know what areas of the field to focus on. In order to help better direct the viewer to the most prominent differences, we can mask the image so that we only show the extreme differences.</p>
<div class="layout-chunk" data-layout="1-page">
<pre class="python"><code>
#Here&#39;s our mask. It may seem weird to use &quot;masked_inside&quot; here when we want the values on the extremes (outside these numbers), but keep in mind this is the &quot;masked&quot; array - so the mask_inside will hide all values inside these boundaries
#You can manually set these numbers, but for simplicity and consistency I&#39;m going to go with the top and bottom quartiles of our differences. Show I&#39;m showing the top 25% units where Mahomes has higher density than Carr, and the top 25% where Carr has higher density than Mahomse
diff_masked = np.ma.masked_inside(diff_kde, np.percentile(diff_kde, 25), np.percentile(diff_kde, 75))

plt.style.use(&#39;seaborn-talk&#39;)

fig, ax1 =plt.subplots(1,1)


plt.imshow(np.fliplr(np.rot90(diff_masked,3)),
           origin=&#39;lower&#39;, aspect=&#39;equal&#39;,
           extent=[-30, 30, -10, 60],
           norm = mpl.colors.Normalize(vmin=-0.0005, vmax=0.0005),
           cmap=&#39;RdBu_r&#39;)

#Set title, remove ticks and labels
ax1.set_title(&#39;Mahomes (red) vs Carr (blue) - NFL Passing Densities&#39;)
ax1.set_xlabel(&#39;&#39;)
ax1.set_xticks([])</code></pre>
<pre class="python"><code>
ax1.set_yticks([])</code></pre>
<pre class="python"><code>
ax1.set_ylabel(&#39;&#39;)

#Remove any part of the plot that is out of bounds
ax1.set_xlim(-53.3333/2, 53.3333/2)</code></pre>
<pre class="python"><code>
ax1.set_ylim(-10,60)


#Plot all of the field markings (line of scrimmage, hash marks, etc.)</code></pre>
<pre class="python"><code>
for j in range(-10,60,1):
    ax1.annotate(&#39;--&#39;, (-3.1,j-0.5),
                 ha=&#39;center&#39;,fontsize =10)
    ax1.annotate(&#39;--&#39;, (3.1,j-0.5),
                 ha=&#39;center&#39;,fontsize =10)
    
for i in range(-10,60,5):
    ax1.axhline(i,c=&#39;k&#39;,ls=&#39;-&#39;,alpha=0.5, lw=1.5)
    
for i in range(-10,60,10):
    ax1.axhline(i,c=&#39;k&#39;,ls=&#39;-&#39;,alpha=0.7, lw=1.5)
    
for i in range(10,60-1,10):
    ax1.annotate(str(i), (-12.88,i-1.15),
            ha=&#39;center&#39;,fontsize =15,
                rotation=270)
    
    ax1.annotate(str(i), (12.88,i-0.65),
            ha=&#39;center&#39;,fontsize =15,
                rotation=90)

ax1.annotate(&#39;Line of Scrimmage&#39;, (16,0),
             textcoords=&quot;offset points&quot;, # how to position the text
                 xytext=(0,5), # distance from text to points (x,y)
                 ha=&#39;center&#39;,fontsize = 9) # horizontal alignment can be left, right or center</code></pre>
<p><img src="player-density-and-completion-surface-estimates_files/figure-html5/masked-1.png" width="998" /></p>
</div>
<p>So now a viewer can pretty easily see the most relevant differences between two players. In this case, Carr is far more likely to target players around the line of scrimmage, while Mahomes is more likely to do deep screens (&lt;-5 yards) or passes past the 10 yardline. If you arent a fan of the red and blue, you can play around with all of the <a href="https://matplotlib.org/tutorials/colors/colormaps.html">available matplotlib colormaps</a>. Again, I recommend a diverging map for this kind of plot but you can certainly get creative.</p>
<h2 id="expected-completion-surfaces">Expected Completion Surfaces</h2>
<p>While densities can help tell us tendencies, they dont tell us how well a player performed when targeting a certain area of the field. Ideally, wed like to match this pass location data to play by play data and look at the expected points added of each throw, but due to the inconsistincies with the way different stadiums record air yards thats quite difficult to do (though I highly encourage any ambitious reader to try. Youd add a lot to this field if you can pull it off). Since we dont have expected points, well try the next best thing: expected completion percentage.</p>
<p>In our dataset, we have the x and y coordinate of the pass, the player who threw the ball, the team they threw it against, some final game information (final score, game location) and whether or not the pass was completed. For now well just estimate probabilities for the whole league, focusing on just the x and y coordinate of the pass. Now Im not a statistician, so I cant say for certain what model is best for this task. Thankfully, the amazing creators of the original NGS scraper <em>are</em> trained statisticians, and theyve laid out in <a href="https://arxiv.org/abs/1906.03339">their paper</a> why <em>generalized additive models</em> would be a good choice for this task. To quickly summarise, they allow us to both capture potential nonlinearities while also giving us a very smooth output, which is both nice for plotting and likely matches the reality of throwing a football (it is unlikely that there are very jagged differences or harsh cutoffs in difficulty as pass locations move throughout the field, but rather wed expect the change in the true completion percentage to be smooth).</p>
<div class="layout-chunk" data-layout="l-body">
<pre class="python"><code>
#We have to do a bit of cleaning to get the data in a form we can use for the model. First, we need to convert out pass_type column into a binary variable instead of the categorical complete, incomplete, touchdown, and interception. 
df[&#39;is_complete&#39;] = 0
df.loc[((df[&#39;pass_type&#39;]==&#39;COMPLETE&#39;) | (df[&#39;pass_type&#39;]==&#39;TOUCHDOWN&#39;)), &#39;is_complete&#39;] = 1

#Now let&#39;s see the distribution of our outcome
print(df.is_complete.mean())</code></pre>
<pre><code>
0.6532767626998791</code></pre>
</div>
<p>Our classes are a bit unbalanced. We have more complete passes than incomplete, though not too drastically so. This class imbalance would be more important if we had imbalanced penalties for assigning incorrect classes. In other words, if we cared more about false negatives than false positives. In this case, it is no worse to predict an incomplete pass complete, than it is to predict a complete pass incomplete (unlike many systems we may try to model in the medical field). So the main reason we care about class imbalance here is when it comes to assessing the performance of our model; because 65% of our passes are complete, just predicting every single pass will be complete will already get us to 65% accuracy. This post isnt meant to be a deep dive in classification, so were not going to address the class imbalance further.</p>
<p>Lets use a similar model structure to the one introduced by Mallepalle et al.(2019) Sticking with python, well take advantage of the <a href="https://pygam.readthedocs.io/en/latest/notebooks/quick_start.html">PyGAM library</a> here.</p>
<div class="layout-chunk" data-layout="l-body">
<pre class="python"><code>
#Get the features and outcomes we care about
X = df[[&#39;x_coord&#39;,&#39;y_coord&#39;]]
y = df[[&#39;is_complete&#39;]]
#Fit our model
gam = LogisticGAM().fit(X, y)
#Test the accuracy of our model
gam.summary()</code></pre>
<pre><code>
LogisticGAM                                                                                               
=============================================== ==========================================================
Distribution:                      BinomialDist Effective DoF:                                     30.9458
Link Function:                        LogitLink Log Likelihood:                                -25666.4423
Number of Samples:                        43839 AIC:                                            51394.7762
                                                AICc:                                           51394.8243
                                                UBRE:                                               3.1729
                                                Scale:                                                 1.0
                                                Pseudo R-Squared:                                   0.0928
==========================================================================================================
Feature Function                  Lambda               Rank         EDoF         P &gt; x        Sig. Code   
================================= ==================== ============ ============ ============ ============
s(0)                              [0.6]                20           17.1         0.00e+00     ***         
s(1)                              [0.6]                20           13.8         0.00e+00     ***         
intercept                                              1            0.0          7.85e-05     ***         
==========================================================================================================
Significance codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1

WARNING: Fitting splines and a linear function to a feature introduces a model identifiability problem
         which can cause p-values to appear significant when they are not.

WARNING: p-values calculated in this manner behave correctly for un-penalized models or models with
         known smoothing parameters, but when smoothing parameters have been estimated, the p-values
         are typically lower than they should be, meaning that the tests reject the null too readily.</code></pre>
<pre class="python"><code>
gam.accuracy(X,y)</code></pre>
<pre><code>
0.7013389903966788</code></pre>
</div>
<p>So with a quick simple model weve improved the accuracy of just assuming every pass will be complete, but were still incorrectly classifying 30% of passes. This isnt too surprising though - weve got many different quarterbacks throwing the ball to many different wide receivers against many different defenses. Just including the location of the pass <em>shouldnt</em> get us too accurate of a model, or wed start to think that players dont matter!</p>
<p>One very useful aspect of GAMs is that because they are an <strong>additive</strong> model, we can explore how each feature is influencing the model output by holding the other features constant at their average value. Lets plot what that looks like.</p>
<div class="layout-chunk" data-layout="l-body">
<pre class="python"><code>
##I&#39;ll confess I just copy and pasted this straight from the pygam documentation, you could definitely clean these up further and add relevant titles. 
for i, term in enumerate(gam.terms):
    if term.isintercept:
        continue
        

    XX = gam.generate_X_grid(term=i)
    pdep, confi = gam.partial_dependence(term=i, X=XX, width=0.95)

    plt.figure()
    plt.plot(XX[:, term.feature], pdep)
    plt.plot(XX[:, term.feature], confi, c=&#39;r&#39;, ls=&#39;--&#39;)
    plt.title(repr(term))
    if i == 0:
      plt.show()</code></pre>
<p><img src="player-density-and-completion-surface-estimates_files/figure-html5/partial_dependencies-1.png" width="624" /><img src="player-density-and-completion-surface-estimates_files/figure-html5/partial_dependencies-2.png" width="624" /></p>
</div>
<p>I find these plots to be super cool (yes Im a nerd but hey, youre the one reading an open-source football post!) because they can let us easily see where the decreased probability in throwing a pass in certain areas of the field come from. One thing that immediately jumps out from these plots is that the only real influence of the x coordinate is passes close to either sideline. Otherwise, it is the depth of the pass (y coordinate) that is the driver behind the difficulty in completing it. This is exactly why a linear model would not do well here - the difference in completion probability from x coordinate 28 to x coordinate 25 is far different than the difference in cp from x coordinate 18 to x coordinate 15.</p>
<p>Okay so weve fit our model and explored the feature dependencies a bit, but how do we go about visualizing this?</p>
<p>Similar to our KDE plotting, well build a helper function for this</p>
<div class="layout-chunk" data-layout="1-page">
<pre class="python"><code>
def gam_helper(df):
    x = df[[&#39;x_coord&#39;,&#39;y_coord&#39;]]
    y = df[&#39;is_complete&#39;]
        #Similar to our KDE helper, we want a mesh grid that we will eventually evaluate the model on
    X, Y = np.mgrid[-30:30:121j, -10:60:141j]
        #Once again we want to flatten and stack our coordinates
    positions = np.vstack([X.ravel(), Y.ravel()])
        #Instead of a kde we fit a gam. Here I&#39;m adjusting the number of splines to avoid overfitting, since we aren&#39;t doing any sort of hold out or cross validation in this post
    gam = LogisticGAM(s(0, n_splines=8) + s(1, n_splines=8) + te(0,1)).fit(x, y)
        #Generate probabilities at the positions specified, transpose them, and put them back into the grid shape for plotting
    Z = np.reshape(gam.predict_mu(positions.T).T, X.shape)
    return Z
    
#Call our function
pass_gam = gam_helper(df)


#Plot our output, same code as before
plt.style.use(&#39;seaborn-talk&#39;)

fig, ax1 =plt.subplots(1,1)

#This is where the magic happens here. Because of the way we performed the KDE, we have to rotate our data 270 degrees to plot in the orientation we want (np.rot90)
#Next, we want to make sure a pixel in the left direction is the same coordinate distance as a pixel in the vertical direction, so we set aspect to equal
#The extent is setting the coordinate system of the displayed image (along with the &quot;origin&quot; parameter). This is necessary to make sure that what we are indicating is the 20 yard line shows up as the 20 yardline in the pic
#Next, we want to normalize our colormap so that 0 is in the exact middle of the colormap. We can do this by having vmin and vmax have the same absolute value
#Lastly, we set the colormap parameter. I like &quot;diverging&quot; colormaps that have white in the middle for comparison plots, so it is clear which values are positive, negative, and 0.
plt.imshow(np.fliplr(np.rot90(pass_gam,3)),
           origin=&#39;lower&#39;, aspect=&#39;equal&#39;,
           extent=[-30, 30, -10, 60],
           norm = mpl.colors.Normalize(vmin=0, vmax=1),
           cmap=&#39;PiYG&#39;)
#Add a &quot;colorbar&quot;, a scale so people know what color represents what
cbar = plt.colorbar()
cbar.set_label(&quot;\nEstimated Completion Probability&quot;)

#Set title, remove ticks and labels
ax1.set_title(&#39;League-wide Estimated Completion Probability&#39;)
ax1.set_xlabel(&#39;&#39;)
ax1.set_xticks([])</code></pre>
<pre class="python"><code>
ax1.set_yticks([])</code></pre>
<pre class="python"><code>
ax1.set_ylabel(&#39;&#39;)

#Remove any part of the plot that is out of bounds
ax1.set_xlim(-53.3333/2, 53.3333/2)</code></pre>
<pre class="python"><code>
ax1.set_ylim(-10,60)


#Plot all of the field markings (line of scrimmage, hash marks, etc.)</code></pre>
<pre class="python"><code>
for j in range(-10,60,1):
    ax1.annotate(&#39;--&#39;, (-3.1,j-0.5),
                 ha=&#39;center&#39;,fontsize =10)
    ax1.annotate(&#39;--&#39;, (3.1,j-0.5),
                 ha=&#39;center&#39;,fontsize =10)
    
for i in range(-10,60,5):
    ax1.axhline(i,c=&#39;k&#39;,ls=&#39;-&#39;,alpha=0.5, lw=1.5)
    
for i in range(-10,60,10):
    ax1.axhline(i,c=&#39;k&#39;,ls=&#39;-&#39;,alpha=0.7, lw=1.5)
    
for i in range(10,60-1,10):
    ax1.annotate(str(i), (-12.88,i-1.15),
            ha=&#39;center&#39;,fontsize =15,
                rotation=270)
    
    ax1.annotate(str(i), (12.88,i-0.65),
            ha=&#39;center&#39;,fontsize =15,
                rotation=90)

ax1.annotate(&#39;Line of Scrimmage&#39;, (16,0),
             textcoords=&quot;offset points&quot;, # how to position the text
                 xytext=(0,5), # distance from text to points (x,y)
                 ha=&#39;center&#39;,fontsize = 9) # horizontal alignment can be left, right or center</code></pre>
<p><img src="player-density-and-completion-surface-estimates_files/figure-html5/gam-1.png" width="998" /></p>
</div>
<p>There are a few different ways we can expand on this. First, we could play around with the model more. We didnt do any hold out or cross validation in our model, we just checked the accuracy of the model on the data it was trained on.</p>
<p>Additionally, the original expected completion surface model introduced by Mallepalle et. al (2019) used smooth tensor products (ti) for all terms, whereas the python GAM library does not have this functionality - instead I just used spline terms and a tensor product term. So, our results differ a bit (though they should be expected to differ some because Ive included the 2019 season which was not in the original paper). In general for statistical modeling I prefer and recommend using R, however I wanted to try keeping this post all in python.</p>
<p>A logical next step is to estimate completion probabilities for a given QB or against a given defense. The simple way of doing this is very straightforward. You just filter your dataframe using .loc to get the QB or team you want, and repeat the process above. However, youre going to be left with a model that is very likely to be overfit (admittedly Ive done this quite a bit on twitter, but as I said before - Im not a statistician!). Derek Carr for instance only has a handful of passes deep, but we would not expect that small sample size to be representative of the true completion percentage if Carr threw to every square yard on the field thousands of times. To combat that, one approach you can use is what Mallepalle et. al did and use a 2-Dimensional Naive Bayesian approach where you leverage the sample size of the entire league but give it less weight as the QB of interest has completed a greater number of passes in a given location of the field. Source code for this from the Mallepalle et al.paper can be found <a href="https://github.com/ryurko/next-gen-scrapy/blob/master/jqas_paper_code.Rmd">here</a>, which is what I drew from below (though the source code is in R, its quite straightforward to adapt to python.)</p>
<div class="layout-chunk" data-layout="l-body">
<pre class="python"><code>
#league-wide data
#median number of passes 
med_n_passes = df.groupby(by=&#39;name&#39;)[&#39;x_coord&#39;].count().median()
#league-wide comp. probability estimates
league_gam = gam_helper(df)
#league-wide kde
league_kde = kde_helper(df, &#39;&#39;)

#QB data
qb_name = &#39;Mahomes&#39;
qb_df = df.loc[(df[&#39;name&#39;].str.contains(qb_name))]
#Qb passes
n_qb = len(qb_df)
#QB comp. prob
qb_gam = gam_helper(qb_df)
#QB kde
qb_kde = kde_helper(df, qb_name)

#Everyone&#39;s favorite phrase - regress to the mean!
regressed_model = (med_n_passes*league_gam*league_kde + n_qb*qb_gam*qb_kde) / (med_n_passes*league_kde + n_qb*qb_kde)</code></pre>
</div>
<p>Plotting this using the exact same code as before should show us how like Mahomes is to complete a pass at any part of the field, accounting for how little we know about his true ability in each area of the field.</p>
<div class="layout-chunk" data-layout="1-page">
<pre class="python"><code>
plt.style.use(&#39;seaborn-talk&#39;)
fig, ax1 =plt.subplots(1,1)

plt.imshow(np.fliplr(np.rot90(regressed_model,3)),
           origin=&#39;lower&#39;, aspect=&#39;equal&#39;,
           extent=[-30, 30, -10, 60],
           norm = mpl.colors.Normalize(vmin=0, vmax=1),
           cmap=&#39;PiYG&#39;)
#Add a &quot;colorbar&quot;, a scale so people know what color represents what
cbar = plt.colorbar()
cbar.set_label(&quot;\nMahomes Estimated Completion Probability&quot;)

#Set title, remove ticks and labels
ax1.set_title(&#39;Mahomes Estimated Completion Probability&#39;)
ax1.set_xlabel(&#39;&#39;)
ax1.set_xticks([])</code></pre>
<pre class="python"><code>
ax1.set_yticks([])</code></pre>
<pre class="python"><code>
ax1.set_ylabel(&#39;&#39;)

#Remove any part of the plot that is out of bounds
ax1.set_xlim(-53.3333/2, 53.3333/2)</code></pre>
<pre class="python"><code>
ax1.set_ylim(-10,60)


#Plot all of the field markings (line of scrimmage, hash marks, etc.)</code></pre>
<pre class="python"><code>
for j in range(-10,60,1):
    ax1.annotate(&#39;--&#39;, (-3.1,j-0.5),
                 ha=&#39;center&#39;,fontsize =10)
    ax1.annotate(&#39;--&#39;, (3.1,j-0.5),
                 ha=&#39;center&#39;,fontsize =10)
    
for i in range(-10,60,5):
    ax1.axhline(i,c=&#39;k&#39;,ls=&#39;-&#39;,alpha=0.5, lw=1.5)
    
for i in range(-10,60,10):
    ax1.axhline(i,c=&#39;k&#39;,ls=&#39;-&#39;,alpha=0.7, lw=1.5)
    
for i in range(10,60-1,10):
    ax1.annotate(str(i), (-12.88,i-1.15),
            ha=&#39;center&#39;,fontsize =15,
                rotation=270)
    
    ax1.annotate(str(i), (12.88,i-0.65),
            ha=&#39;center&#39;,fontsize =15,
                rotation=90)

ax1.annotate(&#39;Line of Scrimmage&#39;, (16,0),
             textcoords=&quot;offset points&quot;, # how to position the text
                 xytext=(0,5), # distance from text to points (x,y)
                 ha=&#39;center&#39;,fontsize = 9) # horizontal alignment can be left, right or center</code></pre>
<p><img src="player-density-and-completion-surface-estimates_files/figure-html5/comp_surface-1.png" width="998" /></p>
</div>
<p>This is definitely a different shape than the league-wide model we plotted. But exactly how does it differ? Once again we can answer this by subtracting our two models.</p>
<div class="layout-chunk" data-layout="1-page">
<pre class="python"><code>
diff_gam = regressed_model - league_gam

plt.style.use(&#39;seaborn-talk&#39;)
fig, ax1 =plt.subplots(1,1)
#Remember to change the min and max so again 0 is the midpoint, but the scale is more reasonable for the completion % data
plt.imshow(np.fliplr(np.rot90(diff_gam,3)),
           origin=&#39;lower&#39;, aspect=&#39;equal&#39;,
           extent=[-30, 30, -10, 60],
           norm = mpl.colors.Normalize(vmin=-0.5, vmax=0.5),
           cmap=&#39;PiYG&#39;)

cbar = plt.colorbar()
cbar.set_label(&quot;\n Completion Prob over Leage Avg&quot;)

#Set title, remove ticks and labels
ax1.set_title(&#39;Mahomes Estimated Completion Probability Over Avg&#39;)
ax1.set_xlabel(&#39;&#39;)
ax1.set_xticks([])</code></pre>
<pre class="python"><code>
ax1.set_yticks([])</code></pre>
<pre class="python"><code>
ax1.set_ylabel(&#39;&#39;)

#Remove any part of the plot that is out of bounds
ax1.set_xlim(-53.3333/2, 53.3333/2)</code></pre>
<pre class="python"><code>
ax1.set_ylim(-10,60)


#Plot all of the field markings (line of scrimmage, hash marks, etc.)</code></pre>
<pre class="python"><code>
for j in range(-10,60,1):
    ax1.annotate(&#39;--&#39;, (-3.1,j-0.5),
                 ha=&#39;center&#39;,fontsize =10)
    ax1.annotate(&#39;--&#39;, (3.1,j-0.5),
                 ha=&#39;center&#39;,fontsize =10)
    
for i in range(-10,60,5):
    ax1.axhline(i,c=&#39;k&#39;,ls=&#39;-&#39;,alpha=0.5, lw=1.5)
    
for i in range(-10,60,10):
    ax1.axhline(i,c=&#39;k&#39;,ls=&#39;-&#39;,alpha=0.7, lw=1.5)
    
for i in range(10,60-1,10):
    ax1.annotate(str(i), (-12.88,i-1.15),
            ha=&#39;center&#39;,fontsize =15,
                rotation=270)
    
    ax1.annotate(str(i), (12.88,i-0.65),
            ha=&#39;center&#39;,fontsize =15,
                rotation=90)

ax1.annotate(&#39;Line of Scrimmage&#39;, (16,0),
             textcoords=&quot;offset points&quot;, # how to position the text
                 xytext=(0,5), # distance from text to points (x,y)
                 ha=&#39;center&#39;,fontsize = 9) # horizontal alignment can be left, right or center</code></pre>
<p><img src="player-density-and-completion-surface-estimates_files/figure-html5/comp_diff-1.png" width="998" /></p>
</div>
<p>Mahomes has clearly had more success than most completing passes to the deep middle of the field.</p>
<p>We could go further here by utilizing the mask we used previously and only showing extreme differences (maybe greater or less than 10% above average), but I think this is a good place to stop for this post. I was incredibly pleased with the amount of people who played around with this data and code after the last post, and hopefully this inspires even more. But please remember to <em>credit and cite Sarah Mallepalle and her team at CMU</em>, since so much of this code and the original scraper came from them!</p>
<!--radix_placeholder_article_footer-->
<div class="article-footer">
  <p class="social_footer">
    <span class="article-sharing">
      Share: &nbsp;
      <a href="https://twitter.com/share?text=Player%20Density%20and%20Completion%20Surface%20Estimates&amp;url=https%3A%2F%2Fmrcaseb.github.io%2Fopen-source-football%2Fposts%2F2020-08-29-player-density-and-completion-surface-estimates%2F">
        <i class="fab fa-twitter"></i>
      </a>
      <a href="https://www.facebook.com/sharer/sharer.php?s=100&amp;p[url]=https%3A%2F%2Fmrcaseb.github.io%2Fopen-source-football%2Fposts%2F2020-08-29-player-density-and-completion-surface-estimates%2F">
        <i class="fab fa-facebook"></i>
      </a>
    </span>
  </p>
</div>
<!--/radix_placeholder_article_footer-->
</div>

<div class="d-appendix">
</div>


<!--radix_placeholder_site_after_body-->
<!--/radix_placeholder_site_after_body-->
<!--radix_placeholder_appendices-->
<div class="appendix-bottom">
  <h3 id="updates-and-corrections">Corrections</h3>
  <p>If you see mistakes or want to suggest changes, please <a href="https://github.com/mrcaseb/open-source-football/issues/new">create an issue</a> on the source repository.</p>
  <h3 id="reuse">Reuse</h3>
  <p>Text and figures are licensed under Creative Commons Attribution <a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a>. Source code is available at <a href="https://github.com/mrcaseb/open-source-football">https://github.com/mrcaseb/open-source-football</a>, unless otherwise noted. The figures that have been reused from other sources don't fall under this license and can be recognized by a note in their caption: "Figure from ...".</p>
  <h3 id="citation">Citation</h3>
  <p>For attribution, please cite this work as</p>
  <pre class="citation-appendix short">Douglas (2020, Aug. 29). Open Source Football: Player Density and Completion Surface Estimates. Retrieved from https://mrcaseb.github.io/open-source-football/posts/2020-08-29-player-density-and-completion-surface-estimates/</pre>
  <p>BibTeX citation</p>
  <pre class="citation-appendix long">@misc{douglas2020player,
  author = {Douglas, Ethan},
  title = {Open Source Football: Player Density and Completion Surface Estimates},
  url = {https://mrcaseb.github.io/open-source-football/posts/2020-08-29-player-density-and-completion-surface-estimates/},
  year = {2020}
}</pre>
</div>
<!--/radix_placeholder_appendices-->
<!--radix_placeholder_navigation_after_body-->
<div class="distill-site-nav distill-site-footer">
  <p>2020 - Website creator Sebastian Carl (Twitter: <a href="https://twitter.com/mrcaseb">@mrcaseb</a>)</p>
</div>
<!--/radix_placeholder_navigation_after_body-->


</body>

</html>
